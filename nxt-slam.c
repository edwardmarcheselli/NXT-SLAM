#pragma config(Sensor, S1,     rear_b,         sensorTouch)
#pragma config(Sensor, S2,     front_b,        sensorTouch)
#pragma config(Motor,  motorA,          rightMot,      tmotorNXT, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,          leftMot,       tmotorNXT, PIDControl, driveLeft, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Must start robot in a corner this becomes your 0,0 point on the cartesian coordinate system

#define MAX_ROOM_SIZE 22 //MAX ROOM SIZE will never change this is based on the memory size on the NXT Brick
#define WHEEL_DIAMETER 1 //WHEEL DIAMETER is (in inches) based on the wheels on the robot
#define LONGEST_SIDE 30 //LONGEST SIDE refers to the longest side of the room in which you are mapping (in feet)
#define MAX_STEPS 32700 //Max encoder memory

int bpos[2] = {0,0}; // robot block location
int cpos[2] = {0,0}; // robot cartesian location
int dir = 0; //0 = up (+y) , 1 = right (+x), 2 = down (-y), 3 = left (-x)
short encode_r, encode_l;
short map[MAX_ROOM_SIZE][MAX_ROOM_SIZE];
int block = ((LONGEST_SIDE * 12) / MAX_ROOM_SIZE) + 1; // add 1 inch buffer

void moveForward()
{
	nMotorEncoder[rightMot] = 0;
	nMotorEncoder[leftMot] = 0;
}

void position_zero()
{
	nMotorEncoder[rightMot] = 0;
	nMotorEncoder[leftMot] = 0;
}

void moveStop()
{
	motor[rightMot] = 0;
	motor[leftMot] = 0;
}

void moveTurnRight()
{
	while(nMotorEncoder[rightMot] < 90)
	{
		motor[rightMot] = -50;
		motor[leftMot] = 50;
	}
	motor[rightMot] = 0;
	motor[leftMot] = 0;

	if(dir < 3){
		dir += 1;
		} else {
		dir = 0;
	}
}

//void moveTurnLeft()
//{
//	while(nMotorEncoder[rightMot] < 90)
//	{
//		motor[rightMot] = -50;
//		motor[leftMot] = 50;
//	}
//	motor[rightMot] = 0;
//	motor[leftMot] = 0;

//	if(dir > 0){
//		dir -= 1;
//		} else {
//		dir = 3;
//	}
//}

int distanceDelta(){
	int distance = ((encode_r + nMotorEncoder[rightMot]) + (encode_l + nMotorEncoder[leftMot])) / 2;
	distance = (distance / 360) * 3.14159 * WHEEL_DIAMETER;
	return distance;
}

void updateLocation(){
	switch (dir) {
	case 0:
		cpos[1] += distanceDelta();
		break;
	case 1:
		cpos[0] += distanceDelta();
		break;
	case 2:
		cpos[1] -= distanceDelta();
		break;
	case 3:
		cpos[0] -= distanceDelta();
		break;
	}
	encode_l = 0;
	encode_r = 0;
	position_zero();
}

void blockPosition(){
	bpos[0] = cpos[0] / block;
	bpos[1] = cpos[1] / block;
}


task main()
{
	int go = true;
	moveForward();
	while (go){
		//should never reach max steps based on location update every two seconds
		if(nMotorEncoder[rightMot] == MAX_STEPS || nMotorEncoder[leftMot] == MAX_STEPS){
			moveStop();
			encode_r = nMotorEncoder[rightMot];
			encode_l = nMotorEncoder[leftMot];
			nMotorEncoder[rightMot] = 0;
			nMotorEncoder[leftMot] = 0;
			moveForward();
		}
		//if bumper hit pauses updates location and marks block on the map as a no go area
		if(SensorValue(front_b) == 1 || SensorValue(rear_b) == 1){
			moveStop();
			updateLocation();
			blockPosition();
			map[bpos[0]][bpos[1]] = 1;
			moveTurnRight();
			position_zero();
			moveForward();
		}
		updateLocation();
		blockPosition();
		//turns the robot to avoid no go blocks on the map
		if(map[bpos[0]][bpos[1]] == 1){
			moveStop();
			moveTurnRight();
			moveForward();
		}
		clearTimer(T1);
		int count = 0;
		while(time1[T1] < 2000){
			count += 1;
		}
	}
}
